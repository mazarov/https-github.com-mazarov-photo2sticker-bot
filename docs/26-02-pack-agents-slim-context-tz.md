# ТЗ: улучшение взаимодействия pack-агентов (slim context, контракты)

**Дата:** 26.02.2026  
**Проект:** photo2sticker-bot  
**Статус:** Требования  
**Связано:** `docs/pack-multiagent-requirements.md`, `docs/26-02-pack-agents-max-tokens-latency.md`, `src/lib/pack-multiagent.ts`

---

## 1. Проблема: почему «теряются» токены

**Токены не теряются технически.** Они тратятся повторно из-за того, **как передаётся контекст между агентами**.

### 1.1 Текущий паттерн

На каждом шаге агенту передаётся:

- **system prompt** (большой)
- **user prompt** (большой)
- **output предыдущего агента** (полный JSON)
- при rework: **reasons / suggestions** от Critic

Каждый агент заново «читает» всё это, даже если ему нужна 1/10 информации.

### 1.2 Главная причина перерасхода

Передаётся **семантический контекст**, а агенту нужен **контракт**.

LLM каждый раз:

- парсит длинный JSON
- интерпретирует поля, которые ему не нужны
- тратит токены на **понимание**, а не на **генерацию**

### 1.3 Дублирование правил

Один и тот же смысл (например, Anti-Postcard) повторяется в промптах:

- Brief & Plan
- Captions
- Scenes
- Critic

Оплата за одно и то же правило — 4 раза.

---

## 2. Цели

1. Снизить расход токенов на ввод (prompt) за счёт передачи каждому агенту **только необходимых полей**.
2. Упростить формат ввода там, где возможно: **плоский контракт** вместо большого JSON.
3. Использовать **кэширование system prompt** на стороне API, где поддерживается.
4. Убрать **повторение одних и тех же правил** в промптах downstream-агентов.

Ожидаемый эффект по уровням (оценка):

- Уровень 1 (slim context): **−30–50%** токенов на ввод.
- Уровень 2 (flat contracts): **−15–25%** токенов.
- Уровень 3 (prompt caching): **−20–40%** (за счёт кэша).
- Уровень 4 (kill repetition): **−10–15%**.

---

## 2.4 Базовые показатели из логов (26.02.2026)

Реальный прогон (один пак, тема «жена ругается на мужа…», subject single_female):

| Этап | Агент | systemLen | userLen | Время |
|------|--------|-----------|---------|--------|
| 1 | brief_and_plan | 2202 | 171 | ~56 с |
| 2 | captions | 862 | **832** | ~4 с |
| 2 | scenes | 1081 | **830** | ~44 с |
| 3 | critic | 587 | **3105** | ~22 с |
| 4 (rework) | captions | 862 | **1836** | ~4 с |
| 4 (rework) | scenes | 1081 | **2124** | ~51 с |
| 5 | critic_2 | 587 | **1586** | ~32 с |

Выводы:

- **userLen 832 / 830** — в Captions и Scenes уходит полный plan (JSON с id, name_ru/en, carousel_*, mood, segment_id, story_arc, tone, moments и т.д.). Slim-контракт (moments + tone [+ outfit для Scenes]) дал бы ~250–400 символов → экономия **~400–500 символов на каждый из 4 вызовов** (2 первых + 2 rework).
- **userLen 3105 / 1586** — в Critic уходит полный spec (id, name_*, carousel_*, labels, labels_en, scene_descriptions, …). Для проверки формата достаточно labels + labels_en + scene_descriptions → **сокращение ввода в 2–3 раза**.
- **Таймаут 180 с**: суммарное время пайплайна (56+43+22+50+31 ≈ 202 с) превысило лимит обработчика обновления → `Promise timed out after 180000 ms`. Slim context сам по себе таймаут не снимет, но уменьшит время ответа API (меньше токенов на ввод) и позволит при необходимости увеличить лимит или вынести генерацию в фон.
- **Качество rework**: при полном rework Scenes вернул слишком короткие сцены («{subject} leans in», «{subject} holds mug»), не 18 слов — в промпте rework нужно явно требовать сохранение длины/формата.

---

## 2.5 Архитектурная оценка: реализуемость и эффект

### Можно ли реализовать?

**Да.** Текущий код этому не мешает.

| Что нужно | Как есть сейчас | Что менять |
|-----------|------------------|------------|
| Captions | Получает весь `plan` (BossPlan), в user message — `JSON.stringify(plan, null, 2)` | Формировать user message из полей `plan.moments` и `plan.tone` (и при rework — critic context). Сигнатуру `runCaptions(plan, ...)` можно не менять: внутри просто собирать короткий ввод из `plan`. |
| Scenes | Получает весь `plan` | То же: ввод только `moments`, `subject_mode`. **Outfit** сейчас в Scenes вообще не передаётся (есть в brief, но pipeline сохраняет только `plan`). Нужно один раз сохранить `brief` после Brief & Plan и передать в Scenes `outfit = brief.visual_anchors?.[0] ?? "none"`. |
| Critic | Получает весь `spec` (PackSpecRow) | В user message передавать только `labels`, `labels_en`, `scene_descriptions`, при наличии `scene_descriptions_ru`. Остальные поля (id, name_ru, carousel_*, mood, segment_id и т.д.) Critic для проверки формата не нужны. |
| Rework (captions_rework, scenes_rework) | То же: полный `plan` в каждом вызове | Те же slim-поля, что и в первом проходе, плюс блок с reasons/suggestions и предыдущими версиями. |

Риски:

- **Один момент:** при rework мы передаём в Captions/Scenes «только нужные поля». Если модель в редких случаях опиралась на контекст (например, `story_arc` для тона) — качество может чуть измениться. На практике для формата (9 моментов, тон, outfit) достаточно того, что уже заложено в moments и tone; при сомнениях можно добавить в slim-контракт Captions поле `shareability_hook` из brief (для этого нужно пробросить `brief` в pipeline и в контракт).

Итог: реализация уровня 1 — это по сути **функции форматирования ввода** (slim object или плоский текст) и подстановка их в существующие `runCaptions` / `runScenes` / `runCritic` вместо полного `JSON.stringify`. Новых агентов и смены потока не требуется.

### Поможет ли это?

**Да, заметно.**

- **Plan** в виде полного JSON: ~12–18 полей (id, pack_template_id, name_ru, name_en, carousel_description_ru/en, mood, segment_id, story_arc, tone, day_structure, moments и т.д.). Типичный размер — порядка **600–1200 символов** (≈150–300 токенов) на один user message.
- **Slim для Captions/Scenes:** только `moments` (9 строк) + `tone` (+ при необходимости `outfit`, `subject_mode`) — порядка **250–450 символов** (≈60–120 токенов). Экономия **~90–180 токенов на один вызов**.
- Вызовов с plan: **до 4 за один пак** (captions, scenes, captions_rework, scenes_rework). Итого **≈360–720 токенов** экономии на ввод только за счёт slim plan.
- **Spec** в Critic: полный PackSpecRow (~15+ полей) — ещё **400–800 символов**. Slim (labels + labels_en + scene_descriptions) — примерно вдвое меньше. Экономия **~50–150 токенов на каждый проход Critic** (1–2 прохода за пак).

Суммарно на один пак: **порядка 400–900 токенов** экономии на **вход** (input). Это не «мелочь»: при 4–6 вызовах API на пак доля input в общем числе токенов значима; плюс меньший ввод чуть снижает латентность и стоимость. Уровни 2–4 (плоский текст вместо JSON, кэш system prompt, сжатие повторяющихся правил) дают дополнительный выигрыш поверх этого.

**Вывод:** архитектурно реализовать slim context можно без смены архитектуры; изменения локализованы в формировании user message и при необходимости в пробросе `brief` для Scenes. Эффект — сокращение токенов ввода на сотни за один пак и небольшое снижение стоимости и латентности.

---

## 3. Уровень 1 (ОБЯЗАТЕЛЬНО): Slim Context per Agent

### 3.1 Принцип

Каждый агент получает **только** те поля, которые нужны для его задачи. Остальное не передаётся.

### 3.2 Контракт: Brief & Plan → Captions

**Передавать:**

- `moments` (массив из 9 строк)
- `tone`
- `shareability_hook` (опционально, для тона)

**Не передавать:**

- `visual_anchors`
- outfit (внутри brief)
- `story_arc`
- `carousel_description_ru` / `carousel_description_en`
- `name_ru` / `name_en`
- `mood`, `segment_id`, `sort_order`, `pack_template_id`, `subject_mode`, `id`

### 3.3 Контракт: Brief & Plan → Scenes

**Передавать:**

- `moments` (массив из 9 строк)
- outfit (один элемент из brief: первый элемент `visual_anchors` или явное "none")
- `subject_mode` (single | multi) — для формулировок сцен

**Не передавать:**

- подписи / captions
- `carousel_description_*`
- `mood`, `shareability_hook`
- `name_ru` / `name_en`
- остальные поля brief (persona, setting, situation_types и т.д.), кроме outfit

### 3.4 Контракт: Captions + Scenes + Plan (мета) → Critic

**Передавать:**

- 9 captions (labels / labels_en)
- 9 scene_descriptions (и при наличии — scene_descriptions_ru)
- минимальная мета для контекста: например только `tone` или один флаг «expect awkward moments», без полного plan/brief.

**Не передавать:**

- полный brief
- полный plan (id, carousel_description_*, name_*, story_arc, day_structure и т.д.)

### 3.5 Требования к реализации

- Ввести **типы/интерфейсы контрактов** на вход каждого агента (например `CaptionsInput`, `ScenesInput`, `CriticInput`).
- Реализовать **функции извлечения** из полного результата Brief & Plan и из полного spec в минимальный контракт для следующего агента.
- В user message передавать только этот минимальный контракт (на первом этапе — в виде JSON с урезанным набором полей).

**Критерий приёмки:** в логах (userLen / userPreview) видно, что в user message у Captions и Scenes нет полного plan/brief, только перечисленные поля.

---

## 4. Уровень 2: Replace JSON with Flat Contracts

### 4.1 Принцип

JSON для LLM — дорогой формат (скобки, ключи, кавычки). Там, где это не ломает парсинг ответа, **ввод** можно передавать плоским текстом.

### 4.2 Формат плоского контракта (пример)

Вместо:

```json
{
  "moments": [
    "Missed breakfast, already late",
    "Awkward hotel elevator silence"
  ],
  "tone": "casual, awkward",
  "outfit": "casual military uniform"
}
```

Передавать:

```
MOMENTS:
1. Missed breakfast, already late
2. Awkward hotel elevator silence
...

TONE: casual, awkward
OUTFIT: casual military uniform
```

### 4.3 Где применять

- Ввод для **Captions**: moments + tone (и при rework — предыдущие captions + reasons/suggestions в коротком виде).
- Ввод для **Scenes**: moments + outfit + subject_mode.
- Ввод для **Critic**: список captions (по одной строке) + список scene_descriptions (по одной строке), без обёртки в полный spec.

### 4.4 Требования

- Определить **канонический плоский формат** для каждого входа (разделители, префиксы MOMENTS / TONE / OUTFIT и т.д.).
- Генерация этого текста — в коде (функция `formatCaptionsInput(...)`, `formatScenesInput(...)` и т.д.).
- Ответ агента по-прежнему JSON (для стабильного парсинга), меняется только **ввод**.

**Критерий приёмки:** user message для Captions и Scenes — плоский текст заданного формата; длина user message уменьшилась по сравнению с JSON-dump.

---

## 5. Уровень 3: System Prompt Caching (КРИТИЧНО)

### 5.1 Проблема

Один и тот же system prompt отправляется при каждом вызове. Если API поддерживает кэширование (например, OpenAI prompt caching), повторная отправка одного и того же system prompt не тарифицируется полностью.

### 5.2 Требования

- Проверить поддержку **prompt caching** в используемом API (OpenAI и др.): какие параметры, как помечать кэшируемый блок.
- Если поддерживается: оформить вызов так, чтобы **system message** участвовал в кэше; в запросе меняется только **user content**.
- Если не поддерживается нативно:
  - держать **system prompt короче**;
  - выносить часть правил в **код** (валидация длины, лимиты полей, проверка количества элементов) и не дублировать их в промпте.

### 5.3 Дополнительно

- Зафиксировать в конфиге или коде: какие промпты считаются статическими и подходят для кэша.
- В документации (архитектура пайплайна) указать: «system prompts рассчитаны на кэширование при поддержке API».

**Критерий приёмки:** при наличии поддержки кэша в API — использование кэша для system prompt; в противном случае — сокращение system prompt и перенос части правил в код.

---

## 6. Уровень 4: Kill Repetition Between Agents

### 6.1 Проблема

Правила вроде **Anti-Postcard** или **Human Imperfection** повторяются в промптах Brief & Plan, Captions, Scenes и Critic. Модель «читает» одно и то же несколько раз — перерасход токенов.

### 6.2 Принцип

- **Source of truth** — один раз (например, в Brief & Plan или в общем «контракте пака»).
- Downstream-агенты **не пересказывают** правило, а получают короткую **напоминалку-контракт**.

### 6.3 Пример

Вместо повторения полного блока Anti-Postcard в Captions и Scenes:

- В промпте Captions / Scenes добавить одну строку:

  ```
  NOTE: Moments already include awkward / anti-postcard beats. Do NOT normalize them.
  ```

- Полное описание правила остаётся только в Brief & Plan (или в одном общем месте).

### 6.4 Требования

- Выделить правила, которые сейчас дублируются в нескольких промптах (Anti-Postcard, Human Imperfection, длина подписей, subject lock и т.д.).
- Оставить **полную формулировку** только в одном агенте (или в общем справочнике).
- В остальных промптах — **краткая ссылка-контракт** (1–2 предложения), без повторения деталей.

**Критерий приёмки:** один и тот же смысл не повторяется дословно в 2+ промптах; в downstream — только короткая NOTE.

---

## 7. Целевая архитектура

```
[System Prompts] — cached / static
        ↓
   Brief & Plan
        ↓
   (extract only what's needed)
   ┌─────────────┐
   │             │
Captions       Scenes
   │             │
   └───────┬─────┘
           ↓
        Critic
```

- Каждая стрелка = **минимальный контракт**, не JSON-dump полного результата.
- System prompts по возможности кэшируются; в user message — только slim/flat контракт для данного агента.

---

## 8. Порядок внедрения

| Этап | Уровень | Описание |
|------|---------|----------|
| 1 | Уровень 1 | Slim context: типы контрактов, функции извлечения, передача в агенты только нужных полей |
| 2 | Уровень 4 | Сократить повторение правил в промптах (NOTE вместо полного текста) |
| 3 | Уровень 2 | Плоский формат ввода для Captions, Scenes, Critic |
| 4 | Уровень 3 | Включение prompt caching (или сокращение system + перенос правил в код) |

---

## 9. Ссылки

- Текущая реализация пайплайна: `src/lib/pack-multiagent.ts`
- Общие требования к pack-агентам: `docs/pack-multiagent-requirements.md`
- Латентность и max_tokens: `docs/26-02-pack-agents-max-tokens-latency.md`
