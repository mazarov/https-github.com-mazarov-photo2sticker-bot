# Хранение очищенного листа пака у нас (Supabase Storage)

**Дата:** 15.02.2026  
**Контекст:** При сборке пака мы режем лист, который отправили пользователю как превью (по `pack_sheet_file_id`). Telegram при сохранении фото часто перекодирует PNG в JPEG и убирает прозрачность — в итоге стикеры в паке получаются с непрозрачным фоном. Вариант решения: сохранять очищенный лист (PNG с альфой) у себя и при сборке брать его оттуда.

---

## Создание бакета Storage

В проекте один бакет используется и для загрузки стикеров (воркер), и для листов пака (`pack_sheets/`). Имя бакета задаётся переменной **`SUPABASE_STORAGE_BUCKET`** (по умолчанию `stickers`). Бакет нужно **создать один раз** в Supabase (через Dashboard или API; через SQL схему `storage` Supabase не рекомендует).

### Через Supabase Dashboard

1. Открой проект в [Supabase Dashboard](https://supabase.com/dashboard) → **Storage**.
2. Нажми **New bucket**.
3. **Name:** имя бакета (например `stickers` или `photo2sticker`). Оно должно совпадать с `SUPABASE_STORAGE_BUCKET` в env воркера/API.
4. **Public bucket:** выключено (приватный бакет). Доступ только по service role key (воркер использует `SUPABASE_SERVICE_ROLE_KEY`).
5. При необходимости задай **File size limit** (например 5 MB) и **Allowed MIME types** (например `image/png`, `image/webp`).
6. Создай бакет.

После создания папка `pack_sheets/` появится при первой загрузке очищенного листа пака; отдельно создавать её не нужно.

### Переменная окружения

В env воркера и API (Dockhost / .env) задай:

```env
SUPABASE_STORAGE_BUCKET=stickers
```

(или то имя, которое указал при создании бакета.)

---

## Суть варианта

- После удаления фона с превью (один проход Pixian/rembg) загружаем **очищенный буфер** в Supabase Storage по пути вида `pack_sheets/<batch_id>.png`.
- В `pack_batches` пишем путь в колонку `cleaned_sheet_storage_path`.
- При нажатии «Получить пак»: если путь задан — качаем лист **из нашего Storage**, режем, накладываем подписи. Иначе — текущая схема (скачивание по Telegram `file_id` и при необходимости per-cell rembg).

---

## Плюсы

| Плюс | Пояснение |
|------|-----------|
| **Сохраняется прозрачность** | Файл у нас — PNG с альфой, без перекодировки Telegram. Стикеры в паке получаются с нормально удалённым фоном. |
| **Один проход BG removal** | Превью и пак используют один и тот же очищенный лист; не нужен повторный rembg по ячейкам при `pack_sheet_cleaned`. |
| **Предсказуемый формат** | Мы контролируем размер и тип файла, можно задать политику хранения и очистки. |
| **Не зависим от Telegram** | Не важно, как Telegram обрабатывает отправленное фото; для сборки пака источник данных — мы. |

---

## Минусы и риски

| Минус / риск | Пояснение |
|--------------|-----------|
| **Объём хранилища** | Каждый превью пака = один PNG (порядка сотен KB – 1+ MB). При большом количестве паков нужно считать рост Storage и при необходимости TTL/очистку. |
| **Жизненный цикл файлов** | Нужна политика: когда удалять (например после успешной сборки пака, или по TTL через N дней). Иначе накопление. |
| **Доступ и безопасность** | Storage должен быть доступен только воркеру (service role). Пути не отдавать наружу; не делать бакет публичным для этих файлов. |
| **Дополнительная точка отказа** | Если Storage недоступен или загрузка при превью упала — fallback на текущую схему (Telegram file_id + при необходимости per-cell rembg). Нужно это явно обрабатывать. |
| **Два источника правды** | Превью пользователь видит из Telegram (возможно уже без альфы), пак собирается из нашего файла — визуально могут чуть отличаться (редко, но возможно). |

---

## Альтернативы (кратко)

- **Не хранить у себя, всегда per-cell rembg при сборке** — прозрачность ок, но N вызовов rembg и дольше сборка; превью по-прежнему может терять альфу в Telegram.
- **Не делать один проход на превью** — превью с магентой, сборка как раньше (N rembg). Минус: превью «сырое», UX хуже.
- **Отправлять превью как document вместо photo** — теоретически Telegram может лучше сохранять формат; на практике поведение не гарантировано, плюс другой UX (документ вместо фото).

---

## Вывод

Хранение очищенного листа у нас даёт стабильную прозрачность в паке и сохраняет схему «один проход BG removal». Минусы — рост Storage, необходимость политики удаления и учёт сбоев Storage. Для объёма «паки по запросу» обычно достаточно: лимитировать срок хранения (например удалять через 24–72 ч или после успешной сборки) и в коде всегда иметь fallback на Telegram file_id + per-cell rembg.

---

## Реализация (17.02.2026)

- **Миграция:** `sql/080_pack_cleaned_sheet_storage.sql` — в `pack_batches` добавлена колонка `cleaned_sheet_storage_path`.
- **Превью:** после удаления фона с листа очищенный буфер загружается в Storage по пути `pack_sheets/<batch_id>.png`, путь пишется в `pack_batches.cleaned_sheet_storage_path`. При ошибке загрузки путь не выставляется — сборка идёт по Telegram file_id.
- **Сборка:** если `cleaned_sheet_storage_path` задан, лист скачивается из Storage; иначе — по `pack_sheet_file_id` из Telegram. При сбое скачивания из Storage — fallback на Telegram.
